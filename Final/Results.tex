\section{Results}

  Here the results are presented. First come predictions of running times
  generated by the RAM model. Then come the analyses of the algorithms under
  the VAT model. Last are the results of benchmarking the algorithms.

  \subsection{RAM}
    This paper selected five reference algorithms, with running times well 
    studied under the RAM model. The following table presents those running
    times. These will be used later to make comparisons.
    
    \begin{tabular}{ccc}
      Algorithm     & Average Case  & Worst Case   \\
      BinarySearch  & $O(\log(n))$  & $O(\log(n))$ \\
      Heapsort      & $O(n\log(n))$ & $O(n\log(n))$\\
      Insertionsort & $O(n^2)$      & $O(n^2)$     \\
      Permute       & $O(n)$        & $O(n)$       \\
      Quicksort     & $O(n\log(n))$ & $O(n^2)$     \\
    \end{tabular}
    
    It is left as an excersize for the reader to look these up in any
    algorithms reference text.

  \subsection{VAT}
     This subsection will have a little more to it than the RAM section. There
     will be a table telling about the calculated running times of our 
     algorithms. There might also be some text describing some of the 
     difficulties or nuances of doing the analyses with the new model.

  \subsection{Benchmarks}
    Benchmarking the algorithms on a modern computer is a key step in
    determining whether VAT or RAM more accurately models a computer for the
    purposes of algorithm analysis.
    
    BinarySearch of an integer array was the first algorithm measured.
    Reviewing the results of timing, one would see all search times as 0.000000
    seconds. The BinarySearch procedure executed too quickly, even on a 2 GiB
    array, to produce a result within the precision of the program's
    measurement.
   \begin{center}
    \includegraphics[width=3in]{heapsort.png}
    \includegraphics[width=3in]{insertionsort.png}
   \end{center}
    
    The sorting algorithms were executed on randomly generated integer arrays,
    and the permute procedure was executed on a sorted array to yield a
    randomized array of integers. The accompanying scatter plots show the
    execution times of each procedure at each size input.
    
   \begin{center}
    \includegraphics[width=3in]{permute.png}
    \includegraphics[width=3	in]{quicksort.png}
   \end{center}